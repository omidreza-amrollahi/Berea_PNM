import numpy as np
# remember that we need porespy 1.3.1 and openpnm 2.6.1 for this
import porespy as ps
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import openpnm as op
import scipy as sp
from porespy.networks import regions_to_network, add_boundary_regions
from porespy.networks import _net_dict
from porespy.networks import label_boundary_cells
from porespy.tools import pad_faces
from porespy.tools import make_contiguous
from porespy.metrics import region_surface_areas, region_interface_areas
from skimage import io
from skimage.morphology import binary_dilation
import pickle
ws = op.Workspace()
ws.clear()


# %% Importing the image into the code
# =============================================================================
fname = 'DRP_Berea_400x400x400_3pt4um_Ilastik_Segmented.tiff'
im = io.imread(fname)

im = im > 1
imtype=im.view()
im = sp.array(im, dtype=bool)
im = ~im #it may be commented on some samples (0,1 inversion of binarized image
# to represent 1 for pores and 0 for solids)
im = im.T
print('Initial Porosity:')
print(ps.metrics.porosity(im))
# im=ps.filters.trim_floating_solid(im)
# print('Porosity after removing disconnected matrix:')
# print(ps.metrics.porosity(im))
# im = ps.filters.fill_blind_pores(im)
# print('Porosity after filling in the blind pores:')
# print(ps.metrics.porosity(im))



# %% we can use this to find the porosity of a slice
# =============================================================================
# ps.visualization.set_mpl_style()
# voxel_size = 1.843803  # microns/voxel
# x_profile = ps.metrics.porosity_profile(im, 0)
# y_profile = ps.metrics.porosity_profile(im, 1)
# z_profile = ps.metrics.porosity_profile(im, 2)
# # NBVAL_IGNORE_OUTPUT
# plt.figure(figsize=[6, 6])
# plt.plot(np.linspace(0, im.shape[0]*voxel_size, im.shape[0]), x_profile, 'b-', label='yz-plane', alpha=0.5)
# plt.plot(np.linspace(0, im.shape[1]*voxel_size, im.shape[1]), y_profile, 'r-', label='xz-plane', alpha=0.5)
# plt.plot(np.linspace(0, im.shape[2]*voxel_size, im.shape[2]), z_profile, 'g-', label='xy-plane', alpha=0.5)
# # plt.ylim([0, 100])
# plt.ylabel('Porosity of slice')
# plt.xlabel('Position of slice along given axis')
# plt.legend()
# plt.show()
## =============================================================================



# %%Snow Extraction
# =============================================================================
voxel_size=1.843803e-6 #meters
boundary_faces=['top', 'bottom', 'left', 'right', 'front', 'back']
marching_cubes_area=False
r_max = 5
sigma = 0.35
# -------------------------------------------------------------------------
# SNOW void phase
regions = ps.filters.snow_partitioning(im=im,  r_max=r_max, sigma=sigma, return_all=True)
# regions = ps.filters.snow_partitioning_parallel(im,
#                                                   overlap='dt',
#                                                   divs=2,
#                                                   num_workers=None,
#                                                   mode='parallel',
#                                                   zoom_factor=0.5,
#                                                   r_max=r_max,
#                                                   sigma=sigma,
#                                                   return_all=True)


# %%Plot Output results
# =============================================================================
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=[10, 10])
ax1.imshow(regions.im[1,:,:], origin='lower')
ax2.imshow(regions.dt[1,:,:], origin='lower')
dt_peak = regions.dt.copy()
peaks_dilated = binary_dilation(regions.peaks > 0)
dt_peak[peaks_dilated > 0] = np.nan
cmap = cm.viridis
cmap.set_bad('red', 1.)
ax3.imshow(dt_peak[1,:,:], origin='lower', cmap=cmap)
ax4.imshow(regions.regions[1,:,:], origin='lower')
plt.show()
print(f"Number of regions: {np.unique(regions.regions).size}")
# %%some thing in the middle to use regionprops_3d to analyze properties of each pore
# =============================================================================
# regions_temp = regions.regions*regions.im
# plt.subplots(1, 1, figsize=(6, 6))
# # have a look on the slice that you want
# fig = plt.imshow(regions_temp[:,:,250], cmap=plt.cm.inferno)
# # %% generting regions 3D properties and Listing available props
# props = ps.metrics.regionprops_3D(regions_temp)
# r = props[0]
# attrs = [a for a in r.__dir__() if not a.startswith('_')]
# print(attrs)
# # %% Analyze properties for a single region
# # these inly work in case of a 2D image
# # plt.subplots(1, 1, figsize=(6, 6))
# # plt.imshow(r.image)
# # plt.subplots(1, 1, figsize=(6, 6))
# # plt.imshow(r.border + 0.5*r.inscribed_sphere)
# # plt.subplots(1, 1, figsize=(6, 6))
# # fig = plt.imshow(r.image + 1.0*r.convex_image)
# print(f"Solidity: {r.solidity:.3f}")
# # %% Extracting one property for all regions
# df = ps.metrics.props_to_DataFrame(props)
# plt.figure(figsize=[8, 4])
# plt.subplot(1, 3, 1)
# fig = plt.hist(df['volume'])
# plt.subplot(1, 3, 2)
# fig = plt.hist(df['solidity'])
# plt.subplot(1, 3, 3)
# fig = plt.hist(df['sphericity'])
# df.iloc[0]
# # %% create a composite image of region images
# # Create an image of maximally inscribed spheres
# sph = ps.metrics.props_to_image(regionprops=props, shape=im.shape, prop='inscribed_sphere')
# plt.subplots(1, 1, figsize=(6, 6))
# fig = plt.imshow(sph[15,:,:] + 0.5*(~im[15,:,:]) , cmap=plt.cm.inferno)
# plt.show()
# # %% Creating a colorized image based on region properties
# # Create an image colorized by solidity
# sph = ps.metrics.props_to_image(regionprops=props, shape=im.shape, prop='solidity')
# plt.subplots(1, 1, figsize=(6, 6))
# fig = plt.imshow(sph[1,:,:] + 0.5*(~im[1,:,:]) , cmap=plt.cm.jet)
# =============================================================================


# %% continue with the rest of SNOW extraction
# =============================================================================
im = regions.im
dt = regions.dt
regions = regions.regions
b_num = sp.amax(regions)
# -------------------------------------------------------------------------
# Boundary Conditions
regions = add_boundary_regions(regions=regions, faces=boundary_faces)
# -------------------------------------------------------------------------
# Padding distance transform and image to extract geometrical properties
dt = pad_faces(im=dt, faces=boundary_faces)
im = pad_faces(im=im, faces=boundary_faces)
regions = regions*im
regions = make_contiguous(regions)
# -------------------------------------------------------------------------
# Extract void and throat information from image
net = regions_to_network(im=regions, dt=dt, voxel_size=voxel_size)
# -------------------------------------------------------------------------
# Extract marching cube surface area and interfacial area of regions
if marching_cubes_area:
    areas = region_surface_areas(regions=regions)
    interface_area = region_interface_areas(regions=regions, areas=areas,
                                            voxel_size=voxel_size)
    net['pore.surface_area'] = areas * voxel_size**2
    net['throat.area'] = interface_area.area
# -------------------------------------------------------------------------
# Find void to void connections of boundary and internal voids
boundary_labels = net['pore.label'] > b_num
loc1 = net['throat.conns'][:, 0] < b_num
loc2 = net['throat.conns'][:, 1] >= b_num
pore_labels = net['pore.label'] <= b_num
loc3 = net['throat.conns'][:, 0] < b_num
loc4 = net['throat.conns'][:, 1] < b_num
net['pore.boundary'] = boundary_labels
net['throat.boundary'] = loc1 * loc2
net['pore.internal'] = pore_labels
net['throat.internal'] = loc3 * loc4
# -------------------------------------------------------------------------
# label boundary cells
net = label_boundary_cells(network=net, boundary_faces=boundary_faces)
# -------------------------------------------------------------------------
# assign out values to dummy dict

temp = _net_dict(net)
temp.im = im.copy()
temp.dt = dt
temp.regions = regions
net = temp
# =============================================================================


pn = op.network.GenericNetwork()
pn.update(net)
prj = pn.project
# %% checking the health of the pore network
# =============================================================================
a = pn.check_network_health()
op.topotools.trim(network=pn,pores=a['trim_pores'])

# %% save a vtk file which can be read by paraview
# =============================================================================
# int(sigma*100) is because file names have problems with '.'
fname = 'Berea700_r'+str(r_max)+'_sigma'+str(int(sigma*100))
# prj.export_data(filename=fname, filetype='vtk')


# %% save the image to overlay it with paraview
# =============================================================================
#im = ps.tools.align_image_with_openpnm(im).astype(int)
#ps.io.to_vtk(im, path='Berea700_r'+str(r_max)+'_sigma'+str(sigma))

# %% save a pore network to be read later
# =============================================================================
pickle.dump(net, open( fname+'.dict', "wb" ) )
